# Требования

Решение проблемы с экспортом в случае больших данных

# Реализация

Наивные реализации потребляют много памяти с вероятными утечками. Реализация экспорта выполнена в
классе `CsvExportMySqlBase`. Получение данных из базы происходит частями. После получения результат одной части он
сразу отправляется клиенту, вместо записи всего результата в файл и последующей отправки.

Преобразование данных из базы реализовано двумя способами. Их особенности описаны в
комментариях к методам `CsvExportMySqlBase::prepareActiveRecordData()` и `CsvExportMySqlBase::prepareArrayData()`.

Также при использовании ActiveRecord отключаются обработчики событий `Event::offAll()` с большой вероятностью приводящие
к утечке памяти. Об это в лог пишется соответсвующая запись.

# Использование

1. Реализовать абстрактный класс `CsvExportMySqlBase` и выбранный метод преобразования данных для экспорта. См. PhpDoc
   к `CsvExportMySqlBase`.
2. Добавить экшен экспорта
   Пример:

```php
    public function actionExport(): void
    {
        $useActiveRecord = true;
        $historySearch = new HistorySearch();
        $activeDataProvider = $historySearch->search(Yii::$app->request->queryParams);
        if ($historySearch->hasErrors()) {
            throw new InvalidArgumentException('Ошибка параметров фильтра.');
        }
        (new HistoryEventsCsvExportMySql($activeDataProvider, $useActiveRecord))->send(2000);
    }
```

Значение переменной `$useActiveRecord` установить в соответствии с реализованным методом преобразования данных для
экспорта.

Параметр `$batchSize` метода `send` подобрать экспериментально. Зависит от объема связей и требуемых преобразований
данных. Обычно не более 65_000.

3. В представлении добавить ссылку на созданный экшен.

# Известные ограничения

Количество выгружаемых элементов при лимите памяти 128MB:

- (не реализовано) Наивная реализация с `ActiveRecord` обычно до 100К.
- (реализовано) При использовании ActiveRecord несколько сотен тысяч (Иногда требуется отключать
  события `Event::offAll()`).
- (реализовано) При использовании массивов (словарей) несколько миллионов.
- (не реализовано) Использование `Query` вместо `ActiveQuery` не дает особых преимуществ по ресурсам и времени работы по
  сравнению с предыдущим вариантом с массивами (словарями). Но значительно тяжелее реализуется и поддерживается.

# План развития

Если время получения данных не удовлетворительно, то процесс экспорта можно перенести в фоновую задачу в очереди, а
результат в виде ссылки на скачивание из файлового хранилища слать в нотификации или например на почту.